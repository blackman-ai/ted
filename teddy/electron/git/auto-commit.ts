// SPDX-License-Identifier: AGPL-3.0-or-later
// Copyright (C) 2025 Blackman Artificial Intelligence Technologies Inc.

import { exec } from 'child_process';
import { promisify } from 'util';
import path from 'path';

const execAsync = promisify(exec);

export interface AutoCommitOptions {
  projectRoot: string;
}

/**
 * Manages automatic Git commits for AI-generated changes
 */
export class AutoCommit {
  private projectRoot: string;

  constructor(options: AutoCommitOptions) {
    this.projectRoot = options.projectRoot;
  }

  /**
   * Initialize a Git repository if one doesn't exist
   */
  async init(): Promise<boolean> {
    try {
      const { stdout } = await this.exec('git rev-parse --git-dir');
      return stdout.trim().length > 0;
    } catch {
      // Not a git repo, initialize one
      await this.exec('git init');
      return true;
    }
  }

  /**
   * Check if there are changes to commit
   */
  async hasChanges(): Promise<boolean> {
    try {
      const { stdout } = await this.exec('git status --porcelain');
      return stdout.trim().length > 0;
    } catch {
      return false;
    }
  }

  /**
   * Commit all changes with a generated message
   */
  async commitChanges(files: string[], summary: string): Promise<void> {
    // Check if repo exists, init if needed
    await this.init();

    // Check if there are actually changes
    if (!(await this.hasChanges())) {
      return;
    }

    // Stage changed files
    if (files.length > 0) {
      const fileArgs = files.map(f => `"${f}"`).join(' ');
      await this.exec(`git add ${fileArgs}`);
    } else {
      // Stage all changes if no specific files provided
      await this.exec('git add -A');
    }

    // Generate commit message
    const message = this.generateCommitMessage(summary, files);

    // Commit
    await this.exec(`git commit -m "${this.escapeMessage(message)}"`);
  }

  /**
   * Get the current branch name
   */
  async getCurrentBranch(): Promise<string> {
    try {
      const { stdout } = await this.exec('git branch --show-current');
      return stdout.trim();
    } catch {
      return 'main';
    }
  }

  /**
   * Get recent commit history
   */
  async getRecentCommits(limit: number = 10): Promise<Array<{ hash: string; message: string; date: string }>> {
    try {
      const { stdout } = await this.exec(
        `git log -n ${limit} --pretty=format:"%H|%s|%ai"`
      );

      return stdout
        .trim()
        .split('\n')
        .filter(line => line.length > 0)
        .map(line => {
          const [hash, message, date] = line.split('|');
          return { hash, message, date };
        });
    } catch {
      return [];
    }
  }

  /**
   * Generate a commit message from summary and file list
   */
  private generateCommitMessage(summary: string, files: string[]): string {
    const lines: string[] = [];

    // First line: summary (max 72 chars)
    const shortSummary = summary.length > 72
      ? summary.substring(0, 69) + '...'
      : summary;
    lines.push(shortSummary);

    // Add blank line
    lines.push('');

    // Add file list if available
    if (files.length > 0) {
      lines.push('Files changed:');
      files.forEach(file => {
        lines.push(`  - ${file}`);
      });
      lines.push('');
    }

    // Add attribution
    lines.push('Generated by Teddy AI');

    return lines.join('\n');
  }

  /**
   * Escape special characters in commit message
   */
  private escapeMessage(message: string): string {
    return message
      .replace(/\\/g, '\\\\')
      .replace(/"/g, '\\"')
      .replace(/\$/g, '\\$')
      .replace(/`/g, '\\`');
  }

  /**
   * Execute a git command in the project directory
   */
  private async exec(command: string): Promise<{ stdout: string; stderr: string }> {
    return execAsync(command, {
      cwd: this.projectRoot,
      maxBuffer: 1024 * 1024 * 10, // 10MB
    });
  }
}
